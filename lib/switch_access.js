// Generated by CoffeeScript 1.10.0

/*
Switch Access for webpages
(c) 2012-2015 Leif Ringstad
Dual-licensed under GPL or commercial license (LICENSE and LICENSE.GPL)
Source: http://github.com/leifcr/switch_access
v 1.1.13
 */

(function() {
  var ExecuteMethod, SwitchAccess, SwitchAccessCommon, SwitchAccessElement,
    indexOf1 = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  SwitchAccessCommon = {
    generateRandomUUID: function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r, v;
        r = Math.random() * 16 | 0;
        v = (c === "x" ? r : r & 0x3 | 0x8);
        return v.toString(16);
      });
    },
    options: {

      /*
      Element highlighting using the built in Highlighter object feature
       */
      highlighter: {

        /*
        Use highlighter div element for each element. A div is positioned absolute
        around the element and shown/hidden accordingly
        Default: true
         */
        use: true,

        /*
        Additional content for the highlighter
        Note: The content is placed within every highlighter and multiple
        highlighters can be visible at the same time. It is best to not
        use IDs on elements placed inside the highlighter, to avoid duplicate
        IDs on a page
        Default: ""
         */
        content: "",

        /*
        Class for the highlighter
        Default: "highlighter"
         */
        "class": "highlighter",

        /*
        The class when a highlighter is active/currently selected
        Default: "current"
         */
        current_class: "current",

        /*
        The class when a group is active/currently selected
        Default: "current"
         */
        group_current_class: "current_group",

        /*
        The class when set on a highlighter when activated action is triggered
        Note: only usable if options.visual.delay_before_activating_element is > 0
        Default: "activate"
         */
        activate_class: "activate",

        /*
        Margin between the highlighter and the element
        Default: 5
         */
        margin_to_element: 5,

        /*
        Selector to set size on. (Change in case you have content inside the highlighter you wish to highlight)
         */
        selector_for_set_to_size: ".highlighter",

        /*
        Use CSS watch to watch the element for changes in position and dimensions
        This is only needed if you have javascript or other DOM elements
        that might change the position or size of a switch-enabled element
        Default: false
         */
        watch_for_resize: false,

        /*
        The ID for the holder for all highlighters. Unlikely to need changing
        Default: "sw-highlighter-holder"
         */
        holder_id: "sw-highlighter-holder",

        /*
        Read out the z-index for the element to be highlighted and set to 1 less than the value specified
        on the element.
        If it's set to inherit or auto it will create set z-index 5371 on the element and 5370 on the highlighter
         */
        auto_z_index: true
      },

      /*
      Options specific to highlighting
       */
      highlight: {

        /*
        Options specifict to highlighting a switch-element
         */
        element: {

          /*
          The class when a element is active/currently selected
          Default: "current"
           */
          current_class: "current",

          /*
          The class when a group is active/currently selected
          Default: "current"
           */
          group_current_class: "current_group",

          /*
          The class when set on a switch-element when activated
          action is triggered
          Note: options.visual.delay_before_activating_element must
          be greater than 0
          Default: "activate"
           */
          activate_class: "activate"
        }
      },
      debug: false,

      /*
      Internal options, but can be changed if needed
       */
      internal: {

        /*
        The data attribute for the unique ID on each element and switch highlighter
        Default: "sw-elem"
         */
        unique_element_data_attribute: "sw-elem",

        /*
        Set a unique class on each element
        Default: false
         */
        set_unique_element_class: false
      }
    },

    /*
    Actions (Enumish)
    These should not be overridden, as they are used internally
     */
    actions: {
      none: 0,
      moved_to_next_element: 1,
      moved_to_next_level: 2,
      moved_to_previous_level: 3,
      triggered_action: 10,
      triggered_delayed_action: 11,
      stayed_at_element: 20
    }
  };

  SwitchAccess = (function() {
    function SwitchAccess(options) {
      if (typeof window['__switch_access_sci'] !== "undefined" && window['__switch_access_sci'] !== null) {
        window.__switch_access_sci.setoptions(options);
        return window.__switch_access_sci;
      }
      window.__switch_access_sci = this;

      /*
      Options
       */
      this.options = {

        /*
        Switch/Key settings
         */
        switches: {

          /*
          The number of switches 0 = disable, 1 = single switch, 2 = two switches
          Default: 2
           */
          number_of_switches: 0,

          /*
          Array for the keycodes to use as single switch (Multiple keycodes possible)
          Default: [32, 13]  (32 = 'Space', 13 = 'Enter')
           */
          keys_1: [32, 13],

          /*
          Array of two arrays for the keys to use as two switches
          Default: [[32, 9], [13]] (9 = 'Tab, 32 = 'Space', 13 = 'Enter')
           */
          keys_2: [[9, 32], [13]],

          /*
          Time for single switch scanning to move from element to element
          Default: 1500 milliseconds
           */
          single_switch_move_time: 1500,

          /*
          If the single switch movement should restart/go to index 0 when restarted
          Default: true
           */
          single_switch_restart_on_activate: true,

          /*
          Time after "triggering" a element to it's activated
          Default: 0
           */
          delay_before_activating_element: 0,

          /*
          Delay before an keypress is "allowed" after last keypress.
          Default: 250 ms
           */
          delay_for_allowed_keypress: 250,

          /*
          Groups enabled/disabled (If elements should be grouped or run as single elements)
          Default: true
           */
          groups: true,

          /*
          Set css class on group when highlighting
          Default: true
           */
          groups_highlight_class: true
        },

        /*
        DOM options
         */
        dom: {

          /*
          The class which all elements must have to be a switch controlled element
          The class should be appended with numbers 1,2,3 etc to set order of elements.
          order is unpredicaable if several elements have the same number within a group.
          Use classnames switch-element-1 switch-element-2 or change this value
          Default: "switch-element-"
           */
          element_class: "switch-element-",

          /*
          The jQuery selector from where the first switch element should be searched for.
          Usually this should be body or the first container on the webpage
          Note: Use a selector which selects a single object. Else behaviour is unpredictable
           */
          start_element_selector: "body"
        },

        /*
        Other settings
         */
        key_filter_skip: [".search"],

        /*
        If set to true, the first link within the element is "clicked".
        Else the actual element is clicked.
        FUTURE feature: (on the todo list)
        A data attribute can be set on the element in order to override this on a per-element basis
         */
        activate_first_link: true,

        /*
        Enable/Disable debug
        Note: log4javascript must be available if used
        Default: false
         */
        debug: false,

        /*
        Visual settings
         */
        visual: {

          /*
          Scroll to ensure the entire element in focus is visible (if possible)
          Default: true
           */
          ensure_visible_element: true,

          /*
          The number of pixels for margin to the viewport/window when
          the element is positioned in the viewport/window
          Default: 15
           */
          scroll_offset: 15,

          /*
          Time in milliseconds the scroll will animate
          (set to 0 if instant scroll is preferred)
          Default: 200
           */
          animate_scroll_time: 200,

          /*
          The easing to use for animation
          Default: "linear"
           */
          easing: "linear"
        }
      };

      /*
      Runtime properties
       */
      this.runtime = {
        active: false,
        element_list: null,
        current_list: null,
        parent_list: null,
        element: {
          current: null,
          idx: 0,
          level: 0,
          next_level: 0,
          next_idx: 0,
          parent_idx: 0
        },
        action_triggered: false,
        keypress_allowed: true,
        single_switch: {
          timer_id: null,
          running: false,
          activate_triggered: false
        },
        highlighter_holder: null
      };
      this.setoptions(options);
      this.init();
    }

    SwitchAccess.prototype.init = function() {
      var appender;
      if (this.options.debug) {
        appender = null;
        this.logger = log4javascript.getLogger();
        if ($('iframe[id*=log4javascript]').length <= 0) {
          if ($('#logger').length > 0) {
            appender = new log4javascript.InPageAppender("logger");
            appender.setWidth("100%");
            appender.setHeight("100%");
          } else {
            appender = new log4javascript.InPageAppender();
            appender.setHeight("500px");
          }
          appender.setThreshold(log4javascript.Level.ALL);
          this.logger.setLevel(log4javascript.Level.ALL);
          this.logger.addAppender(appender);
        }
      }
      if (this.options.debug) {
        this.log("init");
      }
      if (SwitchAccessCommon.options.highlighter.use) {
        this.createHighlighterHolder();
      }
      this.registerCallbacks();
      return this.start();
    };

    SwitchAccess.prototype.setoptions = function(options) {
      if (this.runtime.active === true) {
        this.stop();
      }
      jQuery.extend(true, SwitchAccessCommon.options, {
        highlighter: options.highlighter,
        highlight: options.highlight,
        internal: options.internal,
        debug: options.debug
      });
      delete options.highlighter;
      delete options.highlight;
      delete options.internal;
      jQuery.extend(true, this.options, options);
    };

    SwitchAccess.prototype.log = function(msg, type, raw) {
      if (type == null) {
        type = "debug";
      }
      if (raw == null) {
        raw = false;
      }
      if (this.options.debug) {
        if (raw) {
          return this.logger[type](msg);
        } else {
          return this.logger[type]("SwitchAccess: " + msg);
        }
      }
    };

    SwitchAccess.prototype.checkForNonNumberedElements = function() {
      var msg;
      if ($("." + this.options.dom.element_class).length > 0) {
        msg = "Warning! " + ($("." + this.options.dom.element_class).length) + " element(s) without numbers found. Class selector is: " + this.options.element_class + ".";
        if (this.options.debug) {
          this.log(msg, "warning");
        }
        console.log("SwitchAccess: " + msg);
      }
    };

    SwitchAccess.prototype.buildListFromjqElement = function(jq_element, parent, depth) {
      var i, not_str, temp_list;
      if (depth == null) {
        depth = 0;
      }
      not_str = "[class*=" + this.options.dom.element_class + "] [class*=" + this.options.dom.element_class + "]";
      i = 0;
      while (i < depth) {
        not_str += " [class*=" + this.options.dom.element_class + "]";
        i++;
      }
      temp_list = jq_element.find("[class*=" + this.options.dom.element_class + "]:visible").not(not_str);
      if (this.options.debug) {
        this.log("buildListFromjqElement - element count " + temp_list.length + " depth: " + depth + " element-classes:" + (jq_element.attr("class")), "trace");
      }
      if (temp_list.length <= 0) {
        return [];
      }
      return this.hashAlizeAndRecurseList(this.sortList(temp_list, this.options.dom.element_class), parent, depth);
    };

    SwitchAccess.prototype.hashAlizeAndRecurseList = function(list, parent, depth) {
      var i, new_element, ret;
      ret = [];
      i = 0;
      while (i < list.length) {
        new_element = new SwitchAccessElement($(list[i]), this.runtime.highlighter_holder, this, parent);
        new_element.children(this.buildListFromjqElement($(list[i]), new_element, depth + 1));
        ret.push(new_element);
        i++;
      }
      return ret;
    };

    SwitchAccess.prototype.sortList = function(list, list_class) {
      var search_regexp_class, search_regexp_num;
      if (this.options.debug) {
        this.log("sortList Sorting list for " + list_class + " Elements: " + list.length);
      }
      search_regexp_class = RegExp(list_class + "\\d+");
      search_regexp_num = /\d+/;
      list.sort((function(_this) {
        return function(a, b) {
          var item_class_name_a, item_class_name_b, num_a, num_b;
          item_class_name_a = search_regexp_class.exec($(a).attr("class"));
          item_class_name_b = search_regexp_class.exec($(b).attr("class"));
          num_a = 0;
          num_b = 0;
          if (item_class_name_a !== null && item_class_name_b !== null) {
            num_a = search_regexp_num.exec(item_class_name_a);
            num_b = search_regexp_num.exec(item_class_name_b);
          }
          return num_a - num_b;
        };
      })(this));
      return list;
    };

    SwitchAccess.prototype.elementWithoutChildren = function(element) {
      var child, j, len, ref, ret;
      if (this.options.debug) {
        this.log("elementWithoutChildren " + (element.uniqueDataAttr()));
      }
      ret = [];
      if (element.children().length === 0) {
        ret.push(element);
      } else {
        ref = element.children();
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          ret = ret.concat(this.elementWithoutChildren(child));
        }
        element.children([]);
        element.destroy();
      }
      return ret;
    };

    SwitchAccess.prototype.flattenElementList = function() {
      var element, j, len, new_list, ref;
      if (this.options.debug) {
        this.log("flattenElementList");
      }
      new_list = [];
      ref = this.runtime.element_list;
      for (j = 0, len = ref.length; j < len; j++) {
        element = ref[j];
        new_list = new_list.concat(this.elementWithoutChildren(element));
      }
      return new_list;
    };

    SwitchAccess.prototype.buildElementList = function() {
      this.runtime.element_list = this.buildListFromjqElement($(this.options.dom.start_element_selector), null, 0);
      if (this.options.switches.groups === false) {
        this.runtime.element_list = this.flattenElementList();
      }
      if (this.options.debug) {
        this.log("buildElementList: count:" + this.runtime.element_list.length + ", class-name: " + this.options.dom.element_class);
      }
    };

    SwitchAccess.prototype.deinit = function() {
      if (this.options.debug) {
        this.log("deinit");
      }
      this.stop();
      return this.removeHighlightdiv();
    };

    SwitchAccess.prototype.start = function() {
      if ((this.options.switches.number_of_switches === 0) || (this.runtime.active === true)) {
        return;
      }
      if (this.options.debug) {
        this.log("start");
      }
      this.buildElementList();
      this.runtime.active = true;
      this.moveToFirstRootElement();
      this.startSingleSwitchTimer();
      return this.runtime.action_triggered = false;
    };

    SwitchAccess.prototype.stop = function() {
      if (this.runtime.active === false) {
        return;
      }
      if (this.options.debug) {
        this.log("stop");
      }
      this.runtime.active = false;
      this.removeHighlight();
      this.removeActivateClass();
      return this.stopSingleSwitchTimer();
    };

    SwitchAccess.prototype.destroy = function() {
      if (this.options.debug) {
        this.log("destroy");
      }
      this.stop();
      this.removeCallbacks();
      this.destroy_elements(this.runtime.element_list);
      this.removeHighlighterHolder();
      this.runtime.element_list = null;
      this.runtime.current_list = null;
      this.runtime.parent_list = null;
      this.runtime.element.current = null;
      this.runtime.highlighter_holder = null;
      return window.__switch_access_sci = null;
    };


    /*
    Destroy elements in a list
    Children of the element will be destroyed by the element itself
     */

    SwitchAccess.prototype.destroy_elements = function(list) {
      var element, j, len;
      if (this.options.debug) {
        this.log("destroy_elements", "trace");
      }
      for (j = 0, len = list.length; j < len; j++) {
        element = list[j];
        element.destroy();
      }
    };

    SwitchAccess.prototype.moveToFirstRootElement = function() {
      this.runtime.element.idx = -1;
      return this.moveToNextElementAtLevel();
    };

    SwitchAccess.prototype.moveToNextElementAtLevel = function() {
      if (this.options.debug) {
        this.log("moveToNextElementAtLevel", "trace");
      }
      this.runtime.element.next_idx = this.runtime.element.idx + 1;
      if (this.runtime.element.next_level === this.runtime.element.level && this.runtime.element.level === 0) {
        if (this.runtime.element.next_idx >= this.runtime.element_list.length) {
          this.runtime.element.next_idx = 0;
        }
      }
      if (this.runtime.element.next_level !== 0) {
        if (this.runtime.element.next_idx >= this.runtime.current_list.length) {
          return this.moveToPreviousLevel();
        }
      }
      if (this.moveToNext()) {
        this.runtime.element.current.jq_element().triggerHandler("switch-access-move", [this.runtime.element.idx, this.runtime.element.level, this.runtime.element.current]);
        return SwitchAccessCommon.actions.moved_to_next_element;
      } else {
        return SwitchAccessCommon.actions.stayed_at_element;
      }
    };

    SwitchAccess.prototype.moveToNextLevel = function() {
      if (this.options.debug) {
        this.log("moveToNextLevel", "trace");
      }
      if (this.runtime.element.current.children().length > 1) {
        this.runtime.element.next_level = this.runtime.element.level + 1;
        this.runtime.element.next_idx = 0;
      }
      if (this.moveToNext()) {
        this.runtime.element.current.parent().jq_element().triggerHandler("switch-access-enter-group", [this.runtime.element.idx, this.runtime.element.level, this.runtime.element.current]);
        return SwitchAccessCommon.actions.moved_to_next_level;
      } else {
        return SwitchAccessCommon.actions.stayed_at_element;
      }
    };

    SwitchAccess.prototype.moveToPreviousLevel = function() {
      if (this.options.debug) {
        this.log("moveToPreviousLevel", "trace");
      }
      this.runtime.element.next_level = this.runtime.element.level - 1;
      this.runtime.element.next_idx = this.runtime.element.parent_idx;
      if (this.runtime.element.next_level < 0) {
        this.runtime.element.next_level = 0;
        this.runtime.element.next_idx = 0;
      }
      if (this.moveToNext()) {
        this.runtime.element.current.jq_element().triggerHandler("switch-access-leave-group", [this.runtime.element.idx, this.runtime.element.level, this.runtime.element.current]);
        return SwitchAccessCommon.actions.moved_to_previous_level;
      } else {
        return SwitchAccessCommon.actions.stayed_at_element;
      }
    };

    SwitchAccess.prototype.moveToNext = function() {
      var list_n;
      if (this.options.debug) {
        this.log("moveToNext Current: I: " + this.runtime.element.next_idx + " L: " + this.runtime.element.level + " Next: I: " + this.runtime.element.next_idx + " L: " + this.runtime.element.next_level);
      }
      this.runtime.action_triggered = true;
      this.runtime.single_switch.activate_triggered = false;
      if ((this.runtime.element.next_level === this.runtime.element.level) && (this.runtime.element.idx === this.runtime.element.next_idx)) {
        return false;
      }
      this.removeHighlight();
      if (this.runtime.element.next_level > this.runtime.element.level) {
        list_n = this.runtime.element.current.children();
        this.runtime.element.parent_idx = this.runtime.element.idx;
        this.runtime.parent_list = this.runtime.current_list;
        this.runtime.element.next_idx = 0;
      } else if (this.runtime.element.next_level < this.runtime.element.level) {
        this.runtime.element.next_idx = this.runtime.element.parent_idx;
        if (this.runtime.element.current.parent() !== null) {
          list_n = this.runtime.parent_list;
        } else {
          list_n = this.runtime.element_list;
        }
      } else if (this.runtime.element.next_level === 0) {
        list_n = this.runtime.element_list;
      } else {
        list_n = this.runtime.current_list;
      }
      list_n[this.runtime.element.next_idx].highlight();
      this.runtime.element.idx = this.runtime.element.next_idx;
      this.runtime.element.level = this.runtime.element.next_level;
      this.runtime.current_list = list_n;
      this.runtime.element.current = list_n[this.runtime.element.idx];
      if (this.options.switches.number_of_switches === 1) {
        if (this.runtime.element.current.jq_element().data("sw-single-stay") === true) {
          this.stopSingleSwitchTimer();
        }
      }
      this.makeElementVisible();
      return true;
    };

    SwitchAccess.prototype.removeHighlight = function() {
      if (this.options.debug) {
        this.log("removeHighlight");
      }
      if (this.runtime.element.current === null) {
        return;
      }
      this.runtime.element.current.removeHighlight();
    };

    SwitchAccess.prototype.removeActivateClass = function() {
      var child, j, len, ref;
      if (this.options.debug) {
        this.log("removeHighlight");
      }
      if (this.runtime.current_list === null) {
        return;
      }
      if (this.runtime.element.current.children().length === 0) {
        this.runtime.element.current.removeActivateClass();
      } else {
        ref = this.runtime.element.current.children();
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.removeActivateClass();
        }
      }
    };


    /*
    Make the element(s) visible. If the current selected element is a group, they are all moved inside the visible area of the screen
     */

    SwitchAccess.prototype.makeElementVisible = function() {
      var diff_to_make_visible, element, scroll_top, scrollval;
      if (this.options.visual.ensure_visible_element !== true) {
        return;
      }
      if (this.options.debug) {
        this.log("makeElementVisible", "trace");
      }
      scrollval = null;
      scroll_top = $(document).scrollTop();
      element = this.runtime.element.current.jq_element();
      if (($(window).height() + scroll_top) < (element.offset().top + element.outerHeight() + this.options.visual.scroll_offset)) {
        diff_to_make_visible = (element.offset().top + element.outerHeight() + this.options.visual.scroll_offset) - ($(document).scrollTop() + $(window).height());
        if (diff_to_make_visible > 0) {
          scrollval = diff_to_make_visible + scroll_top;
        }
      } else if (scroll_top > (element.offset().top - this.options.visual.scroll_offset)) {
        if (element.offset().top - this.options.visual.scroll_offset < 0) {
          scrollval = 0;
        } else {
          scrollval = element.offset().top - this.options.visual.scroll_offset;
        }
      }
      if ((scroll_top !== scrollval) && scrollval !== null) {
        if (this.options.visual.animate_scroll_time === 0) {
          $("html").scrollTop(scrollval);
          return $("html body").scrollTop(scrollval);
        } else {
          $("html").animate({
            scrollTop: scrollval
          }, this.options.visual.animate_scroll_time, this.options.visual.easing);
          return $("html body").animate({
            scrollTop: scrollval
          }, this.options.visual.animate_scroll_time, this.options.visual.easing);
        }
      }
    };

    SwitchAccess.prototype.activateElement = function() {
      var child, j, len, ref;
      if (this.options.debug) {
        this.log("activateElement");
      }
      this.runtime.action_triggered = true;
      this.stopSingleSwitchTimer();
      if (this.options.debug) {
        this.log("Activate Element: idx: " + this.runtime.element.idx + " level: IDX: " + this.runtime.element.level + " uuid: " + (this.runtime.element.current.uniqueDataAttr()));
      }
      if (this.options.switches.delay_before_activating_element === 0) {
        return this.activateElementCallBack();
      } else {
        this.runtime.element.current.jq_element().addClass(this.options.element_activate_class);
        if (this.runtime.element.current.children().length > 0) {
          ref = this.runtime.element.current.children();
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            child.addActivateClass();
          }
        } else {
          this.runtime.element.current.addActivateClass();
        }
        window.setTimeout(((function(_this) {
          return function() {
            _this.removeActivateClass();
            _this.activateElementCallBack();
          };
        })(this)), this.options.switches.delay_before_activating_element);
        return SwitchAccessCommon.actions.triggered_delayed_action;
      }
    };

    SwitchAccess.prototype.activateElementCallBack = function() {
      var el, element_to_click, msg;
      if (this.options.debug) {
        this.log("activateElementCallBack");
      }
      if (this.runtime.element.current.children().length > 1) {
        this.startSingleSwitchTimer();
        return this.moveToNextLevel();
      }
      if (this.runtime.element.current.children().length === 1) {
        el = $(this.runtime.element.current.jq_element()[0]);
      } else {
        el = this.runtime.element.current.jq_element();
      }
      if ((el.is("a")) || (this.activate_first_link === false)) {
        element_to_click = el;
      } else {
        element_to_click = el.find("a");
      }
      if (element_to_click.length <= 0) {
        element_to_click = el;
      }
      if (this.options.debug) {
        this.log("Triggering Element: IDX: " + this.runtime.element.current_idx + " Element Tag: " + ($(element_to_click).get(0).tagName.toLowerCase()) + " Text: " + ($(element_to_click).text()));
      }
      this.runtime.element.current.jq_element().triggerHandler("switch-access-activate", [this.runtime.element.idx, this.runtime.element.level, element_to_click, this.runtime.element.current]);
      if (element_to_click.length > 0) {
        element_to_click[0].click();
        if (this.options.switches.number_of_switches === 1) {
          if (this.options.single_switch_restart_on_activate) {
            this.runtime.next_element_idx = -1;
          }
          this.runtime.next_level = 0;
        }
      } else {
        msg = "Nothing to do. Verify options passed to SwitchAccess";
        if (this.options.debug) {
          this.log(msg, "warn");
        }
        console.log("SwitchAccess: Warning: " + msg);
        return SwitchAccessCommon.actions.none;
      }
      return SwitchAccessCommon.actions.triggered_action;
    };

    SwitchAccess.prototype.singleSwitchTimerCallback = function() {
      if (this.options.debug) {
        this.log("singleSwitchTimerCallback", "trace");
      }
      return this.moveToNextElementAtLevel();
    };

    SwitchAccess.prototype.allowKeyPressCallback = function() {
      if (this.options.debug) {
        this.log("allowKeyPressCallback", "trace");
      }
      return this.runtime.keypress_allowed = true;
    };

    SwitchAccess.prototype.createHighlighterHolder = function() {
      if ($("div#" + SwitchAccessCommon.options.holder_id).length === 0) {
        this.runtime.highlighter_holder = $("<div id=\"" + SwitchAccessCommon.options.highlighter.holder_id + "\"></div>");
        $('body').append(this.runtime.highlighter_holder);
      }
    };

    SwitchAccess.prototype.removeHighlighterHolder = function() {
      return $("div#" + SwitchAccessCommon.options.highlighter.holder_id).remove();
    };

    SwitchAccess.prototype.callbackForKeyPress = function(event) {
      var action, ref, ref1, ref2, ref3, ref4, timeout;
      if (this.options.debug) {
        this.log("callbackForKeyPress keycode: " + event.which + " Allowed: " + this.runtime.keypress_allowed);
      }
      if (this.options.switches.number_of_switches === 0) {
        return;
      }
      action = 0;
      if (this.options.switches.number_of_switches === 1) {
        if (ref = event.which, indexOf1.call(this.options.switches.keys_1, ref) >= 0) {
          if (!this.runtime.keypress_allowed) {
            event.stopPropagation();
            return false;
          }
          if (this.runtime.element.current.jq_element().data("sw-single-stay") === true) {
            if (this.runtime.element.current.jq_element().data("sw-single-noaction") === true || this.runtime.single_switch.activate_triggered === true) {
              action = this.moveToNextElementAtLevel();
              if (this.runtime.element.current.jq_element().data("sw-single-stay") !== true) {
                this.startSingleSwitchTimer();
              }
            } else {
              this.runtime.single_switch.activate_triggered = true;
            }
          }
          if (action === 0) {
            action = this.activateElement();
          }
        }
      } else if (this.options.switches.number_of_switches === 2) {
        if ((ref1 = event.which, indexOf1.call(this.options.switches.keys_2[0], ref1) >= 0) || (ref2 = event.which, indexOf1.call(this.options.switches.keys_2[1], ref2) >= 0)) {
          if (!this.runtime.keypress_allowed) {
            event.stopPropagation();
            return false;
          }
        }
        if (ref3 = event.which, indexOf1.call(this.options.switches.keys_2[0], ref3) >= 0) {
          action = this.moveToNextElementAtLevel();
        }
        if (ref4 = event.which, indexOf1.call(this.options.switches.keys_2[1], ref4) >= 0) {
          action = this.activateElement();
        }
      }
      if (this.runtime.action_triggered) {
        this.runtime.action_triggered = false;
        this.runtime.keypress_allowed = false;
        timeout = this.options.switches.delay_for_allowed_keypress;
        if ((action === SwitchAccessCommon.actions.triggered_action) || (action === SwitchAccessCommon.actions.triggered_delayed_action)) {
          if (this.options.switches.number_of_switches === 1) {
            if (this.options.switches.single_switch_move_time > this.options.switches.delay_before_activating_element) {
              timeout = this.options.switches.single_switch_move_time;
            } else {
              timeout = this.options.switches.delay_before_activating_element;
            }
          } else {
            if (this.options.switches.delay_before_activating_element > timeout) {
              timeout = this.options.switches.delay_before_activating_element;
            }
          }
        }
        if (timeout === 0) {
          this.allowKeyPressCallback();
        } else {
          window.setTimeout(((function(_this) {
            return function() {
              _this.allowKeyPressCallback();
            };
          })(this)), timeout);
        }
        event.stopPropagation();
        return false;
      } else {
        return true;
      }
    };

    SwitchAccess.prototype.startSingleSwitchTimer = function() {
      if (this.options.switches.number_of_switches !== 1) {
        return;
      }
      if (this.options.debug) {
        this.log("startSingleSwitchTimer", "trace");
      }
      this.runtime.single_switch.timer_id = window.setInterval(((function(_this) {
        return function() {
          _this.singleSwitchTimerCallback();
        };
      })(this)), this.options.switches.single_switch_move_time);
      return this.runtime.single_switch.running = true;
    };

    SwitchAccess.prototype.stopSingleSwitchTimer = function() {
      if (this.options.switches.number_of_switches !== 1) {
        return;
      }
      if (this.options.debug) {
        this.log("stopSingleSwitchTimer", "trace");
      }
      window.clearInterval(this.runtime.single_switch.timer_id);
      return this.runtime.single_switch.running = false;
    };

    SwitchAccess.prototype.removeCallbacks = function() {
      if (this.options.debug) {
        this.log("removeCallbacks", "trace");
      }
      return $(document).off("keydown.switch_access");
    };

    SwitchAccess.prototype.registerCallbacks = function() {
      if (this.options.debug) {
        this.log("registerCallbacks", "trace");
      }
      $(document).on("keydown.switch_access", (function(_this) {
        return function(event) {
          return _this.callbackForKeyPress(event);
        };
      })(this));
    };

    return SwitchAccess;

  })();

  window.SwitchAccess = SwitchAccess;

  SwitchAccessElement = (function() {
    function SwitchAccessElement(jq_element, highlight_holder, logger, parent, children) {
      if (highlight_holder == null) {
        highlight_holder = null;
      }
      if (logger == null) {
        logger = null;
      }
      if (parent == null) {
        parent = null;
      }
      if (children == null) {
        children = [];
      }
      this.options = {
        debug: false
      };
      this.runtime = {
        jq_highlighter: null,
        jq_element: jq_element,
        uuid: null,
        watching: false,
        csswatch_init: false,
        parent: parent,
        children: children,
        highlight_holder: null,
        element_zidx: jq_element.css('z-index')
      };
      this.options.debug = SwitchAccessCommon.options.debug;
      if (this.options.debug) {
        this.logger = logger;
      }
      this.runtime.highlight_holder = highlight_holder === null ? $('body') : highlight_holder;
      this.init(this.runtime.highlight_holder);
    }

    SwitchAccessElement.prototype.init = function(highlight_holder) {
      this.uniqueDataAttr(true);
      this.createHighlighter(highlight_holder);
      if (this.options.debug) {
        return this.log("init", "trace");
      }
    };

    SwitchAccessElement.prototype.destroy = function() {
      var child, children, j, jq_element, len, parent, ref;
      if (this.options.debug) {
        this.log("destroy", "trace");
      }
      this.destroyHighlighter();
      ref = this.children();
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        child.destroy();
      }
      parent = null;
      children = null;
      return jq_element = null;
    };

    SwitchAccessElement.prototype.parent = function(parent) {
      if (parent == null) {
        parent = null;
      }
      if (parent === null) {
        return this.runtime.parent;
      } else {
        return this.runtime.parent = parent;
      }
    };

    SwitchAccessElement.prototype.children = function(children) {
      if (children == null) {
        children = null;
      }
      if (children === null) {
        return this.runtime.children;
      } else {
        return this.runtime.children = children;
      }
    };

    SwitchAccessElement.prototype.jq_element = function(jq_element) {
      if (jq_element == null) {
        jq_element = null;
      }
      if (jq_element === null) {
        return this.runtime.jq_element;
      } else {
        return this.runtime.jq_element = jq_element;
      }
    };

    SwitchAccessElement.prototype.log = function(msg, type, raw) {
      if (type == null) {
        type = "debug";
      }
      if (raw == null) {
        raw = false;
      }
      if (this.options.debug && this.logger !== null) {
        if (raw) {
          this.logger.log("Element: " + this.runtime.uuid + " :", type);
          return this.logger.log(msg, type, true);
        } else {
          return this.logger.log("Element: " + this.runtime.uuid + " : " + msg, type);
        }
      }
    };


    /*
    Trigger the active element, link or event depending on options
     */

    SwitchAccessElement.prototype.trigger = function() {
      if (this.options.debug) {
        return this.log("trigger");
      }
    };


    /*
    Show the highlighter and add highlight class to current object
     */

    SwitchAccessElement.prototype.highlight = function(check_children) {
      var child, j, len, ref;
      if (check_children == null) {
        check_children = true;
      }
      if (this.options.debug) {
        this.log("highlight");
      }
      if (this.children().length > 0 && check_children === true) {
        this.runtime.jq_element.addClass(SwitchAccessCommon.options.highlight.element.group_current_class);
        ref = this.children();
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.highlight(false);
        }
        return;
      }
      this.runtime.jq_element.addClass(SwitchAccessCommon.options.highlight.element.current_class);
      if (!SwitchAccessCommon.options.highlighter.use) {
        return;
      }
      this.runtime.jq_highlighter.addClass(SwitchAccessCommon.options.highlighter.current_class);
      if (SwitchAccessCommon.options.highlighter.auto_z_index === true) {
        if (isNaN(this.runtime.element_zidx) === true) {
          this.runtime.jq_element.css('z-index', 5371);
          this.runtime.jq_highlighter.css('z-index', 5370);
        } else {
          this.runtime.jq_highlighter.css('z-index', this.runtime.element_zidx - 1);
        }
      }
      this.runtime.jq_highlighter.show();
      this.setHighlighterSizeAndPosition();
      if (SwitchAccessCommon.options.highlighter.watch_for_resize) {
        if (this.runtime.watching === false) {
          return this.enableCSSWatch();
        }
      }
    };


    /*
    Hide highlighter and remove highlight class on the current object(s)
     */

    SwitchAccessElement.prototype.removeHighlight = function(check_children) {
      var child, j, len, ref;
      if (check_children == null) {
        check_children = true;
      }
      if (this.options.debug) {
        this.log("removeHighlight");
      }
      if (this.children().length > 0 && check_children === true) {
        this.runtime.jq_element.removeClass(SwitchAccessCommon.options.highlight.element.group_current_class);
        ref = this.children();
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.removeHighlight(false);
        }
        return;
      }
      this.runtime.jq_element.removeClass(SwitchAccessCommon.options.highlight.element.current_class);
      this.runtime.jq_element.removeClass(SwitchAccessCommon.options.highlight.element.activate_class);
      if (!SwitchAccessCommon.options.highlighter.use) {
        return;
      }
      this.runtime.jq_highlighter.removeClass(SwitchAccessCommon.options.highlighter.current_class);
      this.runtime.jq_highlighter.removeClass(SwitchAccessCommon.options.highlighter.activate_class);
      this.runtime.jq_highlighter.hide();
      if (SwitchAccessCommon.options.highlighter.auto_z_index === true) {
        this.runtime.jq_element.css('z-index', this.runtime.element_zidx);
      }
      if (SwitchAccessCommon.options.highlighter.watch_for_resize) {
        return this.disableCSSWatch();
      }
    };

    SwitchAccessElement.prototype.addActivateClass = function() {
      this.runtime.jq_element.addClass(SwitchAccessCommon.options.highlight.element.activate_class);
      if (!SwitchAccessCommon.options.highlighter.use) {
        return;
      }
      return this.runtime.jq_highlighter.addClass(SwitchAccessCommon.options.highlighter.activate_class);
    };

    SwitchAccessElement.prototype.removeActivateClass = function() {
      if (this.options.debug) {
        this.log("removeActivateClass");
      }
      this.runtime.jq_element.removeClass(SwitchAccessCommon.options.highlight.element.activate_class);
      if (!SwitchAccessCommon.options.highlighter.use) {
        return;
      }
      return this.runtime.jq_highlighter.removeClass(SwitchAccessCommon.options.highlighter.activate_class);
    };


    /*
    Set Highlighter size and position
     */

    SwitchAccessElement.prototype.setHighlighterSizeAndPosition = function() {
      this.setHighlighterSize(this.runtime.jq_element, this.runtime.jq_highlighter);
      return this.setHighlighterPosition(this.runtime.jq_element, this.runtime.jq_highlighter);
    };


    /*
    Set highlighter position
     */

    SwitchAccessElement.prototype.setHighlighterPosition = function(element, highlighter) {
      var position;
      if (this.options.debug) {
        this.log("m_to_el: " + SwitchAccessCommon.options.highlighter.margin_to_element + ", outerW-innerW: " + (highlighter.outerWidth() - highlighter.width()) + " outerH-innerH: " + (highlighter.outerHeight() - highlighter.innerHeight()), "trace");
      }
      position = {
        top: element.offset().top - SwitchAccessCommon.options.highlighter.margin_to_element - (highlighter.outerHeight() - highlighter.innerHeight()) / 2,
        left: element.offset().left - SwitchAccessCommon.options.highlighter.margin_to_element - (highlighter.outerWidth() - highlighter.innerWidth()) / 2
      };
      if ((highlighter.offset().top === position.top) && (highlighter.offset().left === position.left)) {
        return;
      }
      highlighter.offset(position);
      if (this.options.debug) {
        this.log("setHighlighterPosition left: " + position.left + " top: " + position.top, "trace");
      }
    };


    /*
    Set size on the Highlighter object to the match the given element
     */

    SwitchAccessElement.prototype.setHighlighterSize = function(element, highlighter) {
      var h, w;
      w = element.outerWidth(false) + (SwitchAccessCommon.options.highlighter.margin_to_element * 2);
      h = element.outerHeight(false) + (SwitchAccessCommon.options.highlighter.margin_to_element * 2);
      highlighter.width(w);
      highlighter.height(h);
      if (this.options.debug) {
        this.log("setHighlighterSize w: " + w + ", h: " + h, "trace");
      }
    };


    /*
    Create the highlighter DOM object
     */

    SwitchAccessElement.prototype.createHighlighter = function(jq_holder) {
      if ((SwitchAccessCommon.options.highlighter.use === false) || (this.runtime.jq_highlighter !== null)) {
        return;
      }
      if (this.options.debug) {
        this.log("createHighlight");
      }
      this.runtime.jq_highlighter = $("<div id=\"sw-el-" + this.runtime.uuid + "\" class=\"" + SwitchAccessCommon.options.highlighter["class"] + "\"></div>");
      jq_holder.append(this.runtime.jq_highlighter);
      this.runtime.jq_highlighter.css('position', 'absolute');
      this.runtime.jq_highlighter.hide();
      this.runtime.jq_highlighter.append(SwitchAccessCommon.options.highlighter.content);
      if (SwitchAccessCommon.options.watch_for_resize) {
        if (this.runtime.jq_highlighter.find(SwitchAccessCommon.options.highlighter.selector_for_set_to_size).length === 0) {
          return this.runtime.jq_highlighter.addClass(SwitchAccessCommon.options.highlighter.selector_for_set_to_size);
        }
      }
    };


    /*
    Destroy the highlighter DOM object
     */

    SwitchAccessElement.prototype.destroyHighlighter = function() {
      if (this.runtime.jq_highlighter === null) {
        return;
      }
      if (this.options.debug) {
        this.log("destroyHighlight", "trace");
      }
      this.disableCSSWatch();
      this.runtime.jq_highlighter.remove();
      return this.runtime.jq_highlighter = null;
    };


    /*
    Enable wathcing CSS changes on the element belonging to this object
     */

    SwitchAccessElement.prototype.enableCSSWatch = function() {
      if (!(SwitchAccessCommon.options.highlighter.use === true && SwitchAccessCommon.options.highlighter.watch_for_resize === true)) {
        return;
      }
      if (this.options.debug) {
        this.log("enableCSSWatch", "trace");
      }
      this.runtime.watching = true;
      if (this.runtime.csswatch_init) {
        return this.runtime.jq_element.csswatch('start');
      } else {
        this.runtime.csswatch_init = true;
        return this.runtime.jq_element.csswatch({
          props: "top,left,bottom,right,width,height",
          props_functions: {
            top: "offset().top",
            left: "offset().left",
            bottom: "offset().bottom",
            right: "offset().right",
            width: "outerWidth(false)",
            height: "outerHeight(false)"
          },
          callback: ((function(_this) {
            return function() {
              return _this.callbackForResize();
            };
          })(this))
        });
      }
    };


    /*
    Disable watching CSS changes on the element belonging to this object
     */

    SwitchAccessElement.prototype.disableCSSWatch = function() {
      if (!(SwitchAccessCommon.options.highlighter.use === true && SwitchAccessCommon.options.highlighter.watch_for_resize === true)) {
        return;
      }
      if (this.options.debug) {
        this.log("disableCSSWatch", "trace");
      }
      this.runtime.watching = false;
      return this.runtime.jq_element.csswatch('stop');
    };


    /*
    Add a data attribute to the element that has a unique ID.
    Will also add the same attribute as a class if option
    set_unique_element_class is enabled.
     */

    SwitchAccessElement.prototype.uniqueDataAttr = function(create) {
      if (create == null) {
        create = false;
      }
      if (this.options.debug) {
        this.log("uniqueDataAttr: Create: " + create, "trace");
      }
      if (create) {
        this.runtime.uuid = SwitchAccessCommon.generateRandomUUID();
        this.runtime.jq_element.data(SwitchAccessCommon.options.internal.unique_element_data_attribute, this.runtime.uuid);
        if (SwitchAccessCommon.options.set_unique_element_class === true) {
          this.runtime.jq_element.addClass(SwitchAccessCommon.options.internal.unique_element_data_attribute + "+uuid");
        }
        return this.runtime.uuid;
      } else {
        return this.runtime.uuid;
      }
    };


    /*
    Callback for resize event on this particular element
     */

    SwitchAccessElement.prototype.callbackForResize = function(event, changes) {
      if (this.options.debug) {
        this.log("callbackForResize", "trace");
      }
      if (!SwitchAccessCommon.options.highlighter.use) {
        return;
      }
      this.setHighlighterSize(this.runtime.jq_element, this.runtime.jq_highlighter);
      return this.setHighlighterPosition(this.runtime.jq_element, this.runtime.jq_highlighter);
    };


    /*
    Play the sound for the current element upon highlight
     */


    /*
    Play the sound for the current element upon activation
     */

    return SwitchAccessElement;

  })();


  /*
   * Execute Method
   * (c) 2012 Leif Ringstad
   * Licensed under the freeBSD license (see LICENSE.txt for details)
   *
   * Source: http://github.com/leifcr/execute_method
   * v 1.0.0
   */

  ExecuteMethod = {
    getFunctionsAndProperties: function(str) {
      var arr, i, ret;
      arr = str.split(".");
      i = 0;
      ret = [];
      while (i < arr.length) {
        ret.push(ExecuteMethod.getFunctionAndParameters(arr[i]));
        i++;
      }
      return ret;
    },
    getFunctionAndParameters: function(str) {
      var func, isfunc, params;
      if (ExecuteMethod.isFunction(str)) {
        params = str.substring(str.indexOf("(") + 1, str.indexOf(")"));
        if (params.length > 0) {
          params = ExecuteMethod.splitAndTypeCastParameters(params);
        } else {
          params = [];
        }
        func = str.substring(0, str.indexOf("\("));
        isfunc = true;
      } else {
        func = str;
        params = null;
        isfunc = false;
      }
      return {
        func: func,
        params: params,
        isfunc: isfunc
      };
    },
    splitAndTypeCastParameters: function(params) {
      var arr, i, ret;
      arr = params.split(",");
      ret = [];
      i = 0;
      ret = [];
      while (i < arr.length) {
        ret.push(ExecuteMethod.typecastParameter(arr[i]));
        i++;
      }
      return ret;
    },
    isFunction: function(str) {
      if (ExecuteMethod.regexIndexOf(str, /(\([\d|\D]+\))|(\(\))/, 0) !== -1) {
        return true;
      }
      return false;
    },
    regexIndexOf: function(string, regex, startpos) {
      var indexOf;
      indexOf = string.substring(startpos || 0).search(regex);
      if (indexOf >= 0) {
        return indexOf + (startpos || 0);
      } else {
        return indexOf;
      }
    },
    typecastParameter: function(param) {
      param = param.trim();
      param = param.replace(/^"/, "");
      param = param.replace(/"$/m, "");
      if (param.search(/^\d+$/) === 0) {
        return parseInt(param);
      } else if (param.search(/^\d+\.\d+$/) === 0) {
        return parseFloat(param);
      } else if (param === "false") {
        return false;
      } else if (param === "true") {
        return true;
      }
      return param;
    },
    executeSingleFunction: function(func, params, context, _that) {
      return context[func].apply(_that, params);
    },
    getSingleProperty: function(property, context) {
      return context[property];
    },

    /*
     * @param {String} Provide a string on what to execute (e.g. this.is.something(true).to_run() or myFunction().property or myFunction())
     * @param {Object} Provide a object to run the string provided on
     * @param {Object} Provide an object that points to the "this" pointer which
     */
    executeMethodByFunctionName: function(str, context) {
      var current_context, current_val, func_data, i;
      func_data = ExecuteMethod.getFunctionsAndProperties(str);
      i = 0;
      current_context = context;
      current_val = null;
      while (i < func_data.length) {
        if (func_data[i]["isfunc"] === true) {
          current_context = ExecuteMethod.executeSingleFunction(func_data[i]["func"], func_data[i]["params"], current_context, context);
        } else {
          current_context = ExecuteMethod.getSingleProperty(func_data[i]["func"], current_context);
        }
        i++;
      }
      return current_context;
    }
  };

  if (!String.prototype.trim) {
    String.prototype.trim = function() {
      return this.replace(/^\s+|\s+$/g, '');
    };
  }

  if (window.ExecuteMethod === "undefined" || window.ExecuteMethod === null || window.ExecuteMethod === void 0) {
    window.ExecuteMethod = ExecuteMethod;
  }


  /*
  jQuery css-watch event Coffeescript
  http://github.com/leifcr/jquery-csswatch/
  (c) 2012-2013 Leif Ringstad
  
  @author Leif Ringstad
  @version 1.2.1
  @date 10/27/2013
  
  Licensed under the freeBSD license
   */

  (function($, window, document) {

    /*
      Plugin constructor
     */
    var CssWatch;
    CssWatch = function(elem, options) {
      this.elem = elem;
      this.$elem = $(elem);
      this.options = options;
      this.cb_timer_id = null;
      this.stop_requested = false;
    };

    /*
      Plugin prototype
     */
    CssWatch.prototype = {
      defaults: {
        event_name: "css-change",
        data_attr_name: "css-watch-data",
        use_event: true,
        callback: null,
        props: "",
        props_functions: {}
      },

      /*
        Initializer
       */
      init: function() {
        this.config = $.extend({}, this.defaults, this.options, this.metadata);
        this.config.props = this.splitAndTrimProps(this.config.props);
        if (this.config.props.length > 0) {
          this.setInitialData();
          this.start();
        }
        return this;
      },

      /*
        split and trim properties
       */
      splitAndTrimProps: function(props) {
        var arr, i, ret;
        arr = props.split(",");
        ret = [];
        i = 0;
        while (i < arr.length) {
          ret.push(arr[i].trim());
          i++;
        }
        return ret;
      },

      /*
        set initial data
       */
      setInitialData: function() {
        var i;
        i = 0;
        while (i < this.config.props.length) {
          this.setData(this.config.props[i], this.getPropertyValue(this.config.props[i]));
          i++;
        }
      },

      /*
        set a data element for a css property on the current element
       */
      setData: function(property, value) {
        return this.$elem.data(this.config.data_attr_name + "-" + property, value);
      },

      /*
        update data attributes from changes
       */
      updateDataFromChanges: function(changes) {
        var j, len, property, ref, value;
        ref = Object.keys(changes);
        for (value = j = 0, len = ref.length; j < len; value = ++j) {
          property = ref[value];
          this.setData(property, changes[property]);
        }
      },

      /*
        get the datavalue stored for a property
       */
      getDataValue: function(property) {
        return this.$elem.data(this.config.data_attr_name + "-" + property);
      },

      /*
        get css property value (from jquery css or from custom function if needed)
       */
      getPropertyValue: function(property) {
        var function_to_call;
        if (Object.keys(this.config.props_functions).length === 0) {
          return this.$elem.css(property);
        }
        function_to_call = null;
        if (indexOf1.call(Object.keys(this.config.props_functions), property) >= 0) {
          function_to_call = this.config.props_functions[property];
        } else {
          function_to_call === null;
        }
        if (function_to_call !== null) {
          if (window.ExecuteMethod) {
            return ExecuteMethod.executeMethodByFunctionName(function_to_call, this.$elem);
          } else {
            console.log("You are missing the ExecuteMethod library.");
          }
        }
        return this.$elem.css(property);
      },

      /*
        get object of changes
       */
      changedProperties: function() {
        var i, ret;
        i = 0;
        ret = {};
        while (i < this.config.props.length) {
          if (this.getPropertyValue(this.config.props[i]) !== this.getDataValue(this.config.props[i])) {
            ret[this.config.props[i]] = this.getPropertyValue(this.config.props[i]);
          }
          i++;
        }
        return ret;
      },

      /*
        stop csswatch / checking of css attributes
       */
      stop: function() {
        var stop_requested;
        if (typeof this.config === "undefined" || this.config === null) {
          return;
        }
        stop_requested = true;
        return window.cssWatchCancelAnimationFrame(this.cb_timer_id);
      },

      /*
        start csswatch / checking of css attributes
       */
      start: function() {
        if (typeof this.config === "undefined" || this.config === null) {
          return;
        }
        this.stop_requested = false;
        this.cb_timer_id = window.cssWatchRequestAnimationFrame((function(_this) {
          return function() {
            _this.check();
          };
        })(this));
      },

      /*
        the actual checking of changes
       */
      check: function() {
        var changes;
        if (typeof this.config === "undefined" || this.config === null) {
          return false;
        }
        if (this.stop_requested === true) {
          return false;
        }
        changes = this.changedProperties();
        if (Object.keys(changes).length > 0) {
          if (this.config.use_event) {
            this.$elem.trigger(this.config.event_name, changes);
          }
          if (this.config.callback !== null) {
            this.config.callback.apply(null, [changes]);
          }
          this.updateDataFromChanges(changes);
        }
        this.cb_timer_id = window.cssWatchRequestAnimationFrame((function(_this) {
          return function() {
            _this.check();
          };
        })(this));
        return false;
      },

      /*
       destroy plugin (stop/remove data)
       */
      destroy: function() {
        this.stop();
        this.$elem.removeData("css-watch-object");
        this.$elem.removeData(this.config.data_attr_name);
        return null;
      }
    };

    /*
     Set defaults
     */
    CssWatch.defaults = CssWatch.prototype.defaults;

    /*
     Jquery extension for plugin
     Plugin funcitonality is in the class above
     */
    $.fn.csswatch = function(options) {
      return this.each(function() {
        var data, obj;
        if (typeof options === "object" || !options) {
          data = $(this).data("css-watch-object");
          if (!data) {
            obj = new CssWatch(this, options);
            $(this).data("css-watch-object", obj);
            obj.init();
          }
        } else if (typeof options === "string") {
          obj = $(this).data("css-watch-object");
          if (obj && obj[options]) {
            return obj[options].apply(this);
          }
        }
      });
    };
  })(jQuery, window, document);


  /*
   *
   * Cross browser Object.keys implementation
   *
   * This is suggested implementation from Mozilla for supporting browser that do not implement Object.keys
   * if object doesn't have .keys function
   * if(!Object.keys) Object.keys = function(o){
   *    if (o !== Object(o))
   *       throw new TypeError('Object.keys called on non-object');
   *    var ret=[],p;
   *    for(p in o) if(Object.prototype.hasOwnProperty.call(o,p)) ret.push(p);
   *    return ret;
   * }
   */

  if (!Object.keys) {
    Object.keys = function(o) {
      var p, ret;
      if (o !== Object(o)) {
        throw new TypeError("Object.keys called on non-object");
      }
      ret = [];
      p = void 0;
      for (p in o) {
        if (Object.prototype.hasOwnProperty.call(o, p)) {
          ret.push(p);
        }
      }
      return ret;
    };
  }


  /*
    Cross browser requestAnimationFrame
    Not including settimeout as it will have a static value for timeout
   */

  if (!window.cssWatchRequestAnimationFrame) {
    window.cssWatchRequestAnimationFrame = (function() {
      return window.webkitAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.requestAnimationFrame || function(callback, element) {
        return window.setTimeout(callback, 1000 / 60);
      };
    })();
  }


  /*
    Cross browser cancelAnimationFrame
   */

  if (!window.cssWatchCancelAnimationFrame) {
    window.cssWatchCancelAnimationFrame = (function() {
      return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || function(timeout_id) {
        return window.clearTimeout(timeout_id);
      };
    })();
  }

}).call(this);
